# InterviewMaterialsiOs

## Принципы ООП

ООП - парадигма программирования, в которой основными концепциями являются понятия объектов и классов
Абстрагирование - выделение набора значимых характеристик объекта.
Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе, и скрыть детали реализации от пользователя
Наследование - это свойство системы, позволяющее описать новый класс на основе уже существующего с частичной или полностью заимствующей функциональностью
Полиморфизм - называется способность функции обрабатывать данные разных типов(by теория типов и теория программирования) (способность функции вести себя по-разному в зависимости от контекста. Пример - знак «+» в java)
Виды полиморфизма: специальный полиморфизм (перезагрузка операторов), полиморфизм подтипов(ооп - создаем абстрактный интерфейс, от него наследуем другие классы), параметрический полиморфизм (generics, templates).

В объектно-ориентированном программировании полиморфизм подтипов (или полиморфизм включения) представляет собой концепцию в теории типов, предполагающую использование единого имени (идентификатора) при обращении к объектам нескольких разных классов, при условии, что все они являются подклассами одного общего надкласса (суперкласса). Полиморфизм подтипов состоит в том, что несколько типов формируют подмножество другого типа (их базового класса) и потому могут использоваться через общий интерфейс.
Параметрический полиморфизм позволяет определять функцию или тип данных обобщённо, так что значения обрабатываются идентично вне зависимости от их типа. Параметрически полиморфная функция использует аргументы на основе поведения, а не значения, апеллируя лишь к необходимым ей свойствам аргументов, что делает её применимой в любом контексте, где тип объекта удовлетворяет заданным требованиям поведения. Таким образом, реализуется концепция параметричности[en]. Развитые системы типов (такие как Хиндли — Милнер) предоставляют механизмы для определения полиморфных типов, что делает использование полиморфных функций более удобным и обеспечивает статическую типобезопасность.
Если параметру функции сопоставлен ровно один тип, то такая функция называется мономорфной. Многие языки программирования предоставляют синтаксический механизм для назначения нескольким мономорфным функциям единого имени (идентификатора). В этом случае, в исходном коде становится возможным осуществлять вызов функции с фактическими параметрами разных типов, но в скомпилированном коде фактически происходит вызов различных функций. Стрэчи назвал такую возможность ad hoc полиморфизмом (в русской литературе чаще всего переводится как специальный полиморфизм).

Класс - описываемая на языке терминологии исходного кода модель ещё не существующей сущности (объекта).
Объект - экземпляр класса. Сущность в адресном пространстве вычислительной системы, появляющаяся при создании экземпляра класса или копирования прототипа
Прототип — это объект-образец, по образу и подобию которого создаются другие объекты. Объекты-копии могут сохранять связь с родительским объектом, автоматически наследуя изменения в прототипе; эта особенность определяется в рамках конкретного языка.

## СТРУКТУРЫ ДАННЫХ

Линейный однонаправленный список — это структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством указателей. Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на NULL. Элемент, на который нет указателя, является первым (головным) элементом списка. Здесь ссылка в каждом узле указывает на следующий узел в списке. В односвязном списке можно передвигаться только в сторону конца списка. Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно. 
В информатике линейный список обычно определяется как абстрактный тип данных (АТД), формализующий понятие упорядоченной коллекции данных. На практике линейные списки обычно реализуются при помощи массивов и связных списков.

Свя́зный спи́сок — базовая динамическая структура данных в информатике, состоящая из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или предыдущий узел списка. 
Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

Связный список - медленное добавление элементов, быстрее при рандомной вставке, медленне при поиске, быстрее при удалении прозвольного элемента
Редактирование/удаление/произвольная вставка - быстрее, поиск - медленне

XOR-связный список — структура данных, похожая на обычный двусвязный список, однако в каждом элементе хранящая только один адрес — результат выполнения операции XOR над адресами предыдущего и следующего элементов списка. Для того, чтобы перемещаться по списку, необходимо взять два последовательных адреса и выполнить над ними операцию XOR, которая и даст реальный адрес следующего элемента.

Массив (в некоторых языках программирования также таблица, ряд, матрица) — набор однотипных компонентов (элементов), расположенных в памяти непосредственно друг за другом, доступ к которым осуществляется по индексу (индексам). В отличие от списка, массив является структурой с произвольным доступом
Размерность массива — количество индексов, необходимое для однозначного доступа к элементу массива
Форма или структура массива — количество размерностей и размер (протяжённость) массива для каждой размерности[4], может быть представлен одномерным массивом
В языке программирования APL массив является основным типом данных (при этом нуль-мерный массив называется скаляром, одномерный — вектором, двумерный — матрицей)
Динамическим называется массив, размер которого может меняться во время исполнения программы
Гетерогенным называется массив, в разные элементы которого могут быть непосредственно записаны значения, относящиеся к различным типам данных. 
Тип данных — допустимое множество значений

Ассоциативный массив (словарь) — абстрактный тип данных (интерфейс к хранилищу данных), позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу:
•    INSERT(ключ, значение)
•    FIND(ключ)
•    REMOVE(ключ)

Хеширование (или хэширование, англ. hashing ) – это преобразование входного массива данных определенного типа и произвольной длины в выходную битовую строку фиксированной длины. (md5, sha-1)

Хэш-таблица - это структура данных, реализующая интерфейс ассоциативного массива, а именно,
она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой
пары, операцию поиска и операцию удаления пары по ключу.

Принцип работы хеш-таблицы:

A hashmap works like this (this is a little bit simplified, but it illustrates the basic mechanism):
It has a number of "buckets" which it uses to store key-value pairs in. Each bucket has a unique number - that's what identifies the bucket. When you put a key-value pair into the map, the hashmap will look at the hash code of the key, and store the pair in the bucket of which the identifier is the hash code of the key. For example: The hash code of the key is 235 -> the pair is stored in bucket number 235. (Note that one bucket can store more then one key-value pair).
When you lookup a value in the hashmap, by giving it a key, it will first look at the hash code of the key that you gave. The hashmap will then look into the corresponding bucket, and then it will compare the key that you gave with the keys of all pairs in the bucket, by comparing them with equals().
Now you can see how this is very efficient for looking up key-value pairs in a map: by the hash code of the key the hashmap immediately knows in which bucket to look, so that it only has to test against what's in that bucket.
Looking at the above mechanism, you can also see what requirements are necessary on the hashCode() and equals() methods of keys:
•    If two keys are the same (equals() returns true when you compare them), their hashCode() method must return the same number. If keys violate this, then keys that are equal might be stored in different buckets, and the hashmap would not be able to find key-value pairs (because it's going to look in the same bucket).
•    If two keys are different, then it doesn't matter if their hash codes are the same or not. They will be stored in the same bucket if their hash codes are the same, and in this case, the hashmap will use equals() to tell them apart.


Существуют два основных варианта хеш-таблиц: с цепочками и открытой адресацией. Хеш-таблица содержит некоторый массив , элементы которого есть пары (хеш-таблица с открытой адресацией) или списки пар (хеш-таблица с цепочками).
Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение  играет роль индекса в массиве . Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива .
Ситуация, когда для различных ключей получается одно и то же хеш-значение, называется коллизией. Такие события не так уж и редки — например, при вставке в хеш-таблицу размером 365 ячеек всего лишь 23-х элементов вероятность коллизии уже превысит 50% (если каждый элемент может равновероятно попасть в любую ячейку) — см. парадокс дней рождения. Поэтому механизм разрешения коллизий — важная составляющая любой хеш-таблицы.
В некоторых специальных случаях удаётся избежать коллизий вообще. Например, если все ключи элементов известны заранее (или очень редко меняются), то для них можно найти некоторую совершенную хеш-функцию, которая распределит их по ячейкам хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные хеш-функции, не нуждаются в механизме разрешения коллизий, и называются хеш-таблицами с прямой адресацией.
Число хранимых элементов, делённое на размер массива  (число возможных значений хеш-функции), называется коэффициентом заполнения хеш-таблицы (load factor) и является важным параметром, от которого зависит среднее время выполнения операций.

Коллизии осложняют использование хеш-таблиц, так как нарушают однозначность соответствия между хеш-кодами и данными. Тем не менее, существуют специальные методики для преодоления возникающих сложностей:
•    Метод цепочек: Технология сцепления элементов (chaining) состоит в том, что элементы множества, которым соответствует одно и то же хеш-значение, связываются в цепочку-список. В позиции номер i хранится указатель на голову списка тех элементов, у которых хеш-значение ключа равно i; если таких элементов в множестве нет, в позиции i записан NULL.
•    Открытая адресация: В отличие от хеширования с цепочками, при открытой адресации никаких списков нет, а все записи хранятся в самой хеш-таблице. Каждая ячейка таблицы содержит либо элемент динамического множества, либо NULL.

Метод цепочек: 
Каждая ячейка  массива  содержит указатель на начало списка всех элементов, хеш-код которых равен , либо указывает на их отсутствие. Коллизии приводят к тому, что появляются списки размером больше одного элемента.
В зависимости от того нужна ли нам уникальность значений операции вставки у нас будет работать за разное время. Если не важна, то мы используем список, время вставки в который будет в худшем случае равна . Иначе мы проверяем есть ли в списке данный элемент, а потом в случае его отсутствия мы его добавляем. В таком случае вставка элемента в худшем случае будет выполнена за 
Время работы поиска в наихудшем случае пропорционально длине списка, а если все  ключей захешировались в одну и ту же ячейку (создав список длиной ) время поиска будет равно  плюс время вычисления хеш-функции, что ничуть не лучше, чем использование связного списка для хранения всех  элементов.
Удаления элемента может быть выполнено за , как и вставка, п.ри использовании двухсвязного списка.

Линейное разрешение коллизий
Все элементы хранятся непосредственно в хеш-таблице, без использования связных списков. В отличии от хеширования с цепочками, при использовании этого метода может возникнуть ситуация, когда хеш-таблица окажется полностью заполненной, следовательно будет невозможно добавлять в неё новые элементы. Так что при возникновении такой ситуации решением может быть динамическое увеличение размера хеш-таблицы, с одновременной её перестройкой.
Стратегии поиска
Последовательный поиск
При попытке добавить элемент в занятую ячейку  начинаем последовательно просматривать ячейки  и так далее, пока не найдём свободную ячейку. В неё и запишем элемент.
Линейный поиск
Выбираем шаг . При попытке добавить элемент в занятую ячейку  начинаем последовательно просматривать ячейки  и так далее, пока не найдём свободную ячейку. В неё и запишем элемент. По сути последовательный поиск - частный случай линейного, где .
Квадратичный поиск
Шаг  не фиксирован, а изменяется квадратично: . Соответственно при попытке добавить элемент в занятую ячейку  начинаем последовательно просматривать ячейки  и так далее, пока не найдём свободную ячейку.

Проблемы данных стратегий
Проблем две — крайне нетривиальное удаление элемента из таблицы и образование кластеров — последовательностей занятых ячеек.
Кластеризация замедляет все операции с хеш-таблицей: при добавлении требуется перебирать всё больше элементов, при проверке тоже. Чем больше в таблице элементов, тем больше в ней кластеры и тем выше вероятность того, что добавляемый элемент попадёт в кластер. Для защиты от кластеризации используется двойное хеширование и хеширование кукушки.




Множество — тип и структура данных в информатике, является реализацией математического объекта множество.
Данные типа множество позволяют хранить ограниченное число значений определённого типа без определённого порядка. Повторение значений, как правило, недопустимо. За исключением того, что множество в программировании конечно, оно в общем соответствует концепции математического множества. Для этого типа в языках программирования обычно предусмотрены стандартные операции над множествами.



Стек (англ. stack — стопка; читается стэк) — структура данных, представляющая собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).
Чаще всего принцип работы стека сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю.
В цифровом вычислительном комплексе стек называется магазином — по аналогии с магазином в огнестрельном оружии (стрельба начнётся с патрона, заряженного последним).

О́чередь — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел» (FIFO, First In — First Out). Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди), при этом выбранный элемент из очереди удаляется.

Двусвязная очередь (жарг. дэк, дек от англ. deque — double ended queue; двухсторонняя очередь, двусвязный список, очередь с двумя концами) — структура данных, в которой элементы можно добавлять и удалять как в начало, так и в конец, то есть дисциплинами обслуживания являются одновременно FIFO и LIFO.


Граф — совокупность непустого множества вершин и наборов связей между вершинами.
Объекты представляются как вершины, или узлы графа, а связи — как дуги, или рёбра[1]. Для разных областей применения виды графов могут различаться направленностью, ограничениями на количество связей и дополнительными данными о вершинах или рёбрах.
Многие структуры, представляющие практический интерес в математике и информатике, могут быть представлены графами. Например, строение Википедии можно смоделировать при помощи ориентированного графа, в котором вершины — это статьи, а дуги (ориентированные рёбра) — гиперссылки (тематическая карта).

Дерево — это связный ациклический граф.[1] Связность означает наличие путей между любой парой вершин, ацикличность — отсутствие циклов и то, что между парами вершин имеется только по одному пути.
Лес - упорядоченное множество упорядоченных деревьев.
Ориентированное (направленное) дерево — ацикличный орграф (ориентированный граф, не содержащий циклов), в котором только одна вершина имеет нулевую степень захода (в неё не ведут дуги), а все остальные вершины имеют степень захода 1 (в них ведёт ровно по одной дуге). Вершина с нулевой степенью захода называется корнем дерева, вершины с нулевой степенью исхода (из которых не исходит ни одна дуга) называются концевыми вершинами или листьями.[2]
Корневое дерево — дерево, в котором выделена одна вершина (корень дерева). Формально корневое дерево определяется как конечное множество  одного или более узлов со следующими свойствами:
1    существует один корень дерева 
2    остальные узлы (за исключением корня) распределены среди  непересекающихся множеств , и каждое из множеств является корневым деревом; деревья  называются поддеревьями данного корня 


В компьютерных науках ку́ча — это специализированная структура данных типа дерево, которая удовлетворяет свойству кучи: если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют max-кучами (в качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами). Не существует никаких ограничений относительно того, сколько узлов-потомков имеет каждый узел кучи, хотя на практике их число обычно не более двух. Куча является максимально эффективной реализацией абстрактного типа данных, который называется очередью с приоритетом. Кучи имеют решающее значение в некоторых эффективных алгоритмах на графах, таких, как алгоритм Дейкстры на d-кучах и сортировка методом пирамиды.
Структуру данных куча не следует путать с понятием куча в динамическом распределении памяти. Впервые термин использовался именно для структур данных. В некоторых ранних популярных языках программирования типа ЛИСП обеспечивалось динамическое распределение памяти с использованием структуры данных «куча», которая и дала своё имя выделяемому объёму памяти.[1].
Кучи обычно реализуются в виде массивов, что исключает наличие указателей между её элементами.
Над кучами обычно проводятся следующие операции:
•    найти максимум или найти минимум: найти максимальный элемент в max-куче или минимальный элемент в min-куче, соответственно
•    удалить максимум или удалить минимум: удалить корневой узел в max- или min-куче, соответственно
•    увеличить ключ или уменьшить ключ: обновить ключ в max- или min-куче, соответственно
•    добавить: добавление нового ключа в кучу.
•    слияние: соединение двух куч с целью создания новой кучи, содержащей все элементы обеих исходных.

В информатике объединение (англ. union) представляет собой значение[en] или структуру данных, которое может иметь несколько различных представлений или форматов.
В сильно типизированных языках тип объединение соответствует понятию тип-сумма из теории типов, то есть требует использовать разные конструкторы для значений разных типов.
В слабо типизированных языках, таких как Си и C++, тип объединение реализует каламбур типизации, то есть обеспечивает интерпретацию одного и того же значения в соответствии с разными типами.
В зависимости от конкретного языка и типа, значение объединения может использоваться в таких операциях как присваивание или сравнение в отрыве от информации о конкретном типе или с требованием её наличия.


## Алгоритмы

Алгори́тм — набор инструкций, описывающих порядок действий исполнителя для достижения результата решения задачи за конечное число действий.

Вычисли́тельная сло́жность — понятие в информатике и теории алгоритмов, обозначающее функцию зависимости объёма работы (времени), которая выполняется некоторым алгоритмом, от размера входных данных. 
Алгоритмическая сложность — это зависимость времени исполнения алгоритма от количества входных данных.

Класс сложности — это множество задач распознавания, для решения которых существуют алгоритмы, схожие по вычислительной сложности. 

Класс P вмещает все те проблемы, решение которых считается «быстрым», то есть время решения которых полиномиально зависит от размера входа. Сюда относится сортировка, поиск во множестве, выяснение связности графов и многие другие.

Класс NP содержит задачи, которые недетерминированная машина Тьюринга в состоянии решить за полиномиальное количество шагов от размера входных данных. Их решение может быть проверено детерминированной машиной Тьюринга за полиномиальное количество шагов. Следует заметить, что недетерминированная машина Тьюринга является лишь абстрактной моделью, в то время как современные компьютеры соответствуют детерминированной машине Тьюринга с ограниченной памятью. Поскольку детерминированная машина Тьюринга может рассматриваться как специальный случай недетерминированной машины Тьюринга, класс NP включает в себя класс P, а также некоторые проблемы, для решения которых известны лишь алгоритмы, экспоненциально зависящие от размера входа (то есть неэффективные для больших входов). В класс NP входят многие знаменитые проблемы, такие как задача коммивояжёра, задача выполнимости булевых формул, факторизация и др.

Вопрос о равенстве этих двух классов считается одной из самых сложных открытых проблем в области теоретической информатики. Математический институт Клэя включил эту проблему в список проблем тысячелетия, предложив награду размером в один миллион долларов США за её решение.


Алгоритмы сортировки.

Сортировка выбором - поиск наименьшего или наибольшего элемента и помещение его в начало или конец упорядоченного списка.
Шаги алгоритма:
1    находим номер минимального значения в текущем списке
2    производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции)
3    теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы
Для реализации устойчивости алгоритма необходимо в пункте 2 минимальный элемент непосредственно вставлять в первую неотсортированную позицию, не меняя порядок остальных элементов.


template<typename T>
void selection_sort(T array[], std::size_t size)
{
for (std::size_t idx_i = 0; idx_i < size - 1; idx_i++)
{
std::size_t min_idx = idx_i;
for (std::size_t idx_j = idx_i + 1; idx_j < size; idx_j++)
{
if (array[idx_j] < array[min_idx])
{
min_idx = idx_j;
}
}

if (min_idx != idx_i)
{
std::swap(array[idx_i], array[min_idx]);
}
}
}
Сложность алгоритма: .


Блочная сортировка
Блочная сортировка (Карманная сортировка, корзинная сортировка, англ. Bucket sort) — алгоритм сортировки, в котором сортируемые элементы распределяются между конечным числом отдельных блоков (карманов, корзин) так, чтобы все элементы в каждом следующем по порядку блоке были всегда больше (или меньше), чем в предыдущем. Каждый блок затем сортируется отдельно, либо рекурсивно тем же методом, либо другим. Затем элементы помещаются обратно в массив. Этот тип сортировки может обладать линейным временем исполнения.
Данный алгоритм требует знаний о природе сортируемых данных, выходящих за рамки функций "сравнить" и "поменять местами", достаточных для сортировки слиянием, сортировки пирамидой, быстрой сортировки, сортировки Шелла, сортировки вставкой.

function bucket-sort(A, n) is
buckets ← новый массив из n пустых элементов
for i = 0 to (length(A)-1) do
вставить A[i] в конец массива buckets[msbits(A[i], k)]
for i = 0 to n - 1 do
next-sort(buckets[i])
return Конкатенация массивов buckets[0], ..., buckets[n-1]

Сложность алгоритма .


Сортировка пузырьком: 
Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются  раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован.

void bubble_sort(int *a, int length) {
for (int j = 0; j < length-1; j++) {
for (int i = 0; i < length - j - 1; i++) {
if (a[i] > a[i+1]) {
int b = a[i]; //change for elements
a[i] = a[i+1];
a[i+1] = b;
}
}
}
}

Сложность алгоритма: .



Быстрая сортировка:


Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы.


int qsort(int a[], int left, int right)
{
int l     = left;
int r     = right;
int foo = 0;
int mid = a[(l + r) / 2];

while (l <= r)
{
while ((a[l] < mid) && (l <= right))
{
l++;
}
while ((a[r] > mid) && (r >= left))
{
r--;
}

if (l <= r)
{
foo = a[l];
a[l] = a[r];
a[r] = foo;
l++;
r--;
}
}

if (r > left)
{
qsort(a, left, r);
}
if (l < right)
{
qsort(a, l, right);
}

return 0;
}

Шаги алгоритма таковы:
1    Выбираем в массиве некоторый элемент, который будем называть опорным элементом. Для корректности алгоритма значение этого элемента должно быть между максимальным и минимальным значениями в массиве (включительно). С точки зрения повышения эффективности алгоритма выгоднее всего выбирать медиану; но без дополнительных сведений о сортируемых данных её обычно невозможно получить. Известные стратегии: выбирать постоянно один и тот же элемент, например, средний или последний по положению; выбирать элемент со случайно выбранным индексом. Часто хороший результат даёт выбор в качестве опорного элемента среднего арифметического между минимальным и максимальным элементами массива, особенно для целых чисел (в этом случае опорный элемент не обязан быть элементом сортируемого массива).
2    Операция разделения массива: реорганизуем массив таким образом, чтобы все элементы со значением меньшим или равным опорному элементу, оказались слева от него, а все элементы, превышающие по значению опорный — справа от него. Обычный алгоритм операции:
1    Два индекса — l и r, приравниваются к минимальному и максимальному индексу разделяемого массива, соответственно.
2    Вычисляется значение опорного элемента m по одной из стратегий.
3    Индекс l последовательно увеличивается до тех пор, пока l-й элемент не окажется больше либо равен опорному.
4    Индекс r последовательно уменьшается до тех пор, пока r-й элемент не окажется меньше либо равен опорному.
5    Если r = l — найдена середина массива — операция разделения закончена, оба индекса указывают на опорный элемент.
6    Если l < r — найденную пару элементов нужно обменять местами и продолжить операцию разделения с тех значений l и r, которые были достигнуты. Следует учесть, что если какая-либо граница (l или r) дошла до опорного элемента, то при обмене значение m изменяется на r-й или l-й элемент соответственно, изменяется именно индекс опорного элемента и алгоритм продолжает свое выполнение.
3    Рекурсивно упорядочиваем подмассивы, лежащие слева и справа от опорного элемента.
4    Базой рекурсии являются наборы, состоящие из одного или двух элементов. Первый возвращается в исходном виде, во втором, при необходимости, сортировка сводится к перестановке двух элементов. Все такие отрезки уже упорядочены в процессе разделения.

Сложность алгоритма: O(n log n)

Пирамидальная сортировка

Поразрядная сортировка

Сортировка слиянием
Сортировка слиянием (англ. merge sort) — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи.

Сложность: O(n log n)

Сортировка вставками
Сортировка вставками (англ. Insertion sort) — алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов[1]. Вычислительная сложность - .

for j = 2 to A.length  
key = A[j]
i = j - 1
while i > 0 and A[i] > key
A[i+1] = A[i]
i = i - 1
A[i+1] = key

Timsort — гибридный алгоритм сортировки, сочетающий сортировку вставками и сортировку слиянием

•    По специальному алгоритму входной массив разделяется на подмассивы.
•    Каждый подмассив сортируется сортировкой вставками.
•    Отсортированные подмассивы собираются в единый массив с помощью модифицированной сортировки слиянием.

Сложность: O(nlogn)


Алгоритмы поиска:
Линейный, последовательный поиск:
Линейный, последовательный поиск (также известен как поиск методом полного перебора или в простонародье брутфорса) — алгоритм нахождения заданного значения произвольной функции на некотором отрезке

int function LinearSearch (Array A, int L, int R, int Key);
begin
for X = L to R do
if A[X] = Key then 
return X
return -1; // элемент не найден
end;
Сложность алгоритма: O(n)

Двоичный (бинарный) поиск (также известен как метод деления пополам и дихотомия) — классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины
int binfind(int a[], int x, int left, int right)
{
if (left > right)
{
return -1;
}
int mid = (left + right) / 2;
if (a[mid] == x)
return mid;
if (a[mid] < x)
mid = binfind(a, x, mid + 1, right);
if (a[mid] > x)
mid = binfind(a, x, left, mid - 1);
}

Алгоритмы на графах:

Топологическая сортировка

Топологическая сортировка (Topological sort) — один из основных алгоритмов на графах, который применяется для решения множества более сложных задач. 
Задача топологической сортировки графа состоит в следующем: указать такой линейный порядок на его вершинах, чтобы любое ребро вело от вершины с меньшим номером к вершине с большим номером. Очевидно, что если в графе есть циклы, то такого порядка не существует. 


Обходы в ширину и глубину

Поиск кратчайших путей между вершинами

Алгоритмы текста:

Поиск подстрок: Алгоритм Кнута-Морриса-Карпа

Индексирование текста: Бор, суффиксный массив, суффиксное дерево

Регулярные выражения


## Шифрование:

Хеширование (иногда «хэширование», англ. hashing) — преобразование по определённому алгоритму входного массива данных произвольной длины в выходную битовую строку фиксированной длины. Такие преобразования также называются хеш-функциями или функциями свёртки, а их результаты называют хешем, хеш-кодом, хеш-суммой или сводкой сообщения

В криптографии соль (модификатор) — это строка случайных данных, которая подается на вход хеш-функции вместе с исходными данными. Используется для удлинения строки пароля, что осложняет восстановление группы исходных паролей за один проход полного перебора или с помощью предварительно построенных радужных таблиц. При этом соль не защищает от полного перебора каждого пароля в отдельности. Исходя из назначения соль должна быть уникальной для каждого пароля из хранимого набора хешей и не является секретной, т.е. хранится рядом с хешем пароля в открытом виде.


Шифрова́ние — обратимое преобразование информации в целях сокрытия от неавторизованных лиц, с предоставлением, в это же время, авторизованным пользователям доступа к ней.

В целом, шифрование состоит из двух составляющих — зашифрование и расшифрование.
С помощью шифрования обеспечиваются три состояния безопасности информации[1]:
•    Конфиденциальность.
Шифрование используется для скрытия информации от неавторизованных пользователей при передаче или при хранении.
•    Целостность.
Шифрование используется для предотвращения изменения информации при передаче или хранении.
•    Идентифицируемость.
Шифрование используется для аутентификации источника информации и предотвращения отказа отправителя информации от того факта, что данные были отправлены именно им.

Криптографическая стойкость — свойство криптографического шифра противостоять криптоанализу, то есть анализу, направленному на изучение шифра с целью его дешифрования. Для изучения криптоустойчивости различных алгоритмов была создана специальная теория, рассматривающая типы шифров и их ключи, а также их стойкость. Основателем этой теории является Клод Шеннон. Криптостойкость шифра есть его важнейшая характеристика, которая отражает то, насколько успешно алгоритм решает задачу шифрования


Методы Шифрования
Симметричное шифрование - использует один и тот же ключ для шифрования и расшифрования.
Асимметричное шифрование - использует два разных ключа: один для зашифрования (который также называется открытым), другой для расшифрования (называется закрытым).

Криптографическая система с открытым ключом (или асимметричное шифрование, асимметричный шифр) — система шифрования и/или электронной подписи (ЭП), при которой открытый ключ передаётся по открытому (то есть незащищённому, доступному для наблюдения) каналу и используется для проверки ЭП и для шифрования сообщения. Для генерации ЭП и для расшифровки сообщения используется закрытый ключ[1]. Криптографические системы с открытым ключом в настоящее время широко применяются в различных сетевых протоколах, в частности, в протоколах TLS и его предшественнике SSL (лежащих в основе HTTPS), в SSH. Также используется в PGP, S/MIME.

Симметри́чные криптосисте́мы (также симметричное шифрование, симметричные шифры) — способ шифрования, в котором для шифрования и расшифровывания применяется один и тот же криптографический ключ. До изобретения схемы асимметричного шифрования единственным существовавшим способом являлось симметричное шифрование. Ключ алгоритма должен сохраняться в секрете обеими сторонами. Алгоритм шифрования выбирается сторонами до начала обмена сообщениями.



Библиотеки для шифрования:
https://github.com/project-imas/encrypted-core-data
https://github.com/benoitsan/BBAES
https://github.com/RNCryptor/RNCryptor

Алгоритмы:
Симметричные - AES, ГОСТ, Blowfish, CAST, DES
Асимметричные - RSA, El-Gamal

## МНОГОПОТОЧНОСТЬ

Сначала нужно точно определить, что означает термин "многопоточность" (multithreading). Многопоточность — это специализированная форма многозадачности (multitasking). В основном, выделяют два типа многозадачности: основанную на процессах (process-based) и основанную на потоках (thread-based). По сути, процесс (process) — это выполняющаяся программа. Таким образом, основанная на процессах многозадачностьI — средство, позволяющее вашему компьютеру выполнять несколько программ одновременно. Например, основанная на процессах многозадачность предоставляет вам возможность форматировать текст в текстовом редакторе и в то же время, например, работать с электронной таблицей или искать информацию в Интернете. В многозадачности, основанной на процессах, программа считается мельчайшей единицей кода, которой может управлять планировщик (scheduler).

Многозада́чность (англ. multitasking) — свойство операционной системы или среды выполнения обеспечивать возможность параллельной (или псевдопараллельной) обработки нескольких процессов.

Существует 2 типа многозадачности:
•    Процессная многозадачность (основанная на процессах — одновременно выполняющихся программах). Здесь программа — наименьший элемент управляемого кода, которым может управлять планировщик операционной системы. Более известна большинству пользователей (работа в текстовом редакторе и прослушивание музыки).
•    Поточная многозадачность (основанная на потоках). Наименьший элемент управляемого кода — поток (одна программа может выполнять 2 и более задачи одновременно).

Многопото́чность — свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени. При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины.

Пото́к выполне́ния (тред; от англ. thread — нить) — наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы. Реализация потоков выполнения и процессов в разных операционных системах отличается друг от друга, но в большинстве случаев поток выполнения находится внутри процесса. Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют инструкции процесса (его код) и его контекст (значения переменных, которые они имеют в любой момент времени). В качестве аналогии потоки выполнения процесса можно уподобить нескольким вместе работающим поварам. Все они готовят одно блюдо, читают одну и ту же кулинарную книгу с одним и тем же рецептом и следуют его указаниям, причём не обязательно все они читают на одной и той же странице.

Проце́сс — команда, которая выполняется в текущий момент. Стандарт ISO 9000:2000 определяет процесс как совокупность взаимосвязанных действий, преобразующих входящие данные в исходящие.
Компьютерная программа сама по себе — это только пассивная совокупность инструкций, в то время как процесс — это непосредственное выполнение этих инструкций.
Также, процессом называют выполняющуюся программу и все её элементы: адресное пространство, глобальные переменные, регистры, стек, открытые файлы и т. д.

«Волокна» (англ. fibers). Несколько потоков режима пользователя, исполняющихся в одном потоке режима ядра. Поток пространства ядра потребляет заметные ресурсы, в первую очередь физическую память и диапазон адресов режима ядра для стека режима ядра. Поэтому было введено понятие «волокна» — облегчённого потока, выполняемого исключительно в режиме пользователя. У каждого потока может быть несколько «волокон».


В многопоточной среде часто возникают проблемы, связанные с использованием параллельно исполняемыми потоками одних и тех же данных или устройств. Для решения подобных проблем используются такие методы взаимодействия потоков, как взаимоисключения (мьютексы), семафоры, критические секции и события
•    Взаимоисключения (mutex, мьютекс) — это объект синхронизации, который устанавливается в особое сигнальное состояние, когда не занят каким-либо потоком. Только один поток владеет этим объектом в любой момент времени, отсюда и название таких объектов (от английского mutually exclusive access — взаимно исключающий доступ) — одновременный доступ к общему ресурсу исключается. После всех необходимых действий мьютекс освобождается, предоставляя другим потокам доступ к общему ресурсу. Объект может поддерживать рекурсивный захват второй раз тем же потоком, увеличивая счетчик, не блокируя поток, и требуя потом многократного освобождения. Такова, например, критическая секция в Win32. Тем не менее есть и такие реализации, которые не поддерживают такое и приводят к взаимной блокировке потока при попытке рекурсивного захвата. Это FAST_MUTEX в ядре Windows.
•    Семафоры представляют собой доступные ресурсы, которые могут быть приобретены несколькими потоками в одно и то же время, пока пул ресурсов не опустеет. Тогда дополнительные потоки должны ждать, пока требуемое количество ресурсов не будет снова доступно. Семафоры очень эффективны, поскольку они позволяют одновременный доступ к ресурсам. Семафор есть логическое расширение мьютекса — семафор со счетчиком 1 эквивалентен мьютексу, но счетчик может быть и более 1.
Семафо́р — объект, ограничивающий количество потоков, которые могут войти в заданный участок кода. В более сложных семафорах может использоваться очередь; при этом потоки, ожидающие освобождения семафора, будут проходить через семафор именно в том порядке, в котором они вызывали enter().
•    События. Объект, хранящий в себе 1 бит информации «просигнализирован или нет», над которым определены операции «просигнализировать», «сбросить в непросигнализированное состояние» и «ожидать». Ожидание на просигнализированном событии есть отсутствие операции с немедленным продолжением исполнения потока. Ожидание на непросигнализированном событии приводит к приостановке исполнения потока до тех пор, пока другой поток (или же вторая фаза обработчика прерывания в ядре ОС) не просигнализирует событие. Возможно ожидание нескольких событий в режимах «любого» или «всех». Возможно также создания события, автоматически сбрасываемого в непросигнализированное состояние после пробуждения первого же — и единственного — ожидающего потока (такой объект используется как основа для реализации объекта «критическая секция»). Активно используются в MS Windows, как в режиме пользователя, так и в режиме ядра. Аналогичный объект имеется и в ядре Linux под названием kwait_queue.
•    Критические секции обеспечивают синхронизацию подобно мьютексам за исключением того, что объекты, представляющие критические секции, доступны в пределах одного процесса. События, мьютексы и семафоры также можно использовать в однопроцессном приложении, однако реализации критических секций в некоторых ОС (например, Windows NT) обеспечивают более быстрый и более эффективный[1][2] механизм взаимно-исключающей синхронизации — операции «получить» и «освободить» на критической секции оптимизированы для случая единственного потока (отсутствия конкуренции) с целью избежать любых ведущих в ядро ОС системных вызовов. Подобно мьютексам объект, представляющий критическую секцию, может использоваться только одним потоком в данный момент времени, что делает их крайне полезными при разграничении доступа к общим ресурсам.
•    Условные переменные (condvars). Сходны с событиями, но не являются объектами, занимающими память — используется только адрес переменной, понятие «содержимое переменной» не существует, в качестве условной переменной может использоваться адрес произвольного объекта. В отличие от событий, установка условной переменной в просигнализированное состояние не влечет за собой никаких последствий в случае, если на данный момент нет потоков, ожидающих на переменной. Установка события в аналогичном случае влечет за собой запоминание состояния «просигнализировано» внутри самого события, после чего следующие потоки, желающие ожидать события, продолжают исполнение немедленно без остановки. Для полноценного использования такого объекта необходима также операция «освободить mutex и ожидать условную переменную атомарно». Активно используются в UNIX-подобных ОС. Дискуссии о преимуществах и недостатках событий и условных переменных являются заметной частью дискуссий о преимуществах и недостатках Windows и UNIX.
•    Порт завершения ввода-вывода (IO completion port, IOCP). Реализованный в ядре ОС и доступный через системные вызовы объект «очередь» с операциями «поместить структуру в хвост очереди» и «взять следующую структуру с головы очереди» — последний вызов приостанавливает исполнение потока в случае, если очередь пуста, и до тех пор, пока другой поток не осуществит вызов «поместить». Самой важной особенностью IOCP является то, что структуры в него могут помещаться не только явным системным вызовом из режима пользователя, но и неявно внутри ядра ОС как результат завершения асинхронной операции ввода-вывода на одном из дескрипторов файлов. Для достижения такого эффекта необходимо использовать системный вызов «связать дескриптор файла с IOCP». В этом случае помещенная в очередь структура содержит в себе код ошибки операции ввода-вывода, а также, для случая успеха этой операции — число реально введенных или выведенных байт. Реализация порта завершения также ограничивает число потоков, исполняющихся на одном процессоре/ядре после получения структуры из очереди. Объект специфичен для MS Windows, и позволяет обработку входящих запросов соединения и порций данных в серверном программном обеспечении в архитектуре, где число потоков может быть меньше числа клиентов (нет требования создавать отдельный поток с расходами ресурсов на него для каждого нового клиента).
•    ERESOURCE. Мьютекс, поддерживающий рекурсивный захват, с семантикой разделяемого или эксклюзивного захвата. Семантика: объект может быть либо свободен, либо захвачен произвольным числом потоков разделяемым образом, либо захвачен всего одним потоком эксклюзивным образом. Любые попытки осуществить захваты, нарушающее это правило, приводят к блокировке потока до тех пор, пока объект не освободится так, чтобы сделать захват разрешенным. Также есть операции вида TryToAcquire — никогда не блокирует поток, либо захватывает, либо (если нужна блокировка) возвращает FALSE, ничего не делая. Используется в ядре Windows, особенно в файловых системах — так, например, любому кем-то открытому дисковому файлу соответствует структура FCB, в которой есть 2 таких объекта для синхронизации доступа к размеру файла. Один из них — paging IO resource — захватывается эксклюзивно только в пути обрезания файла, и гарантирует, что в момент обрезания на файле нет активного ввода-вывода от кэша и от отображения в память.
•    Rundown protection. Полудокументированный (вызовы присутствуют в файлах-заголовках, но отсутствуют в документации) объект в ядре Windows. Счетчик с операциями «увеличить», «уменьшить» и «ждать». Ожидание блокирует поток до тех пор, пока операции уменьшения не уменьшат счетчик до нуля. Кроме того, операция увеличения может отказать, и наличие активного в данный момент времени ожидания заставляет отказывать все операции увеличения.

Взаи́мная блокиро́вка (англ. deadlock) — ситуация в многозадачной среде или СУБД, при которой несколько процессов находятся в состоянии бесконечного ожидания ресурсов, занятых самими этими процессами.
Взаимная блокировка – это такое состояние системы, в котором один поток ожидает наступления чего-то, а это что-то не может произойти потому, что другой поток ожидает наступления чего-то от первого потока.

LiveLock. Это слово означает такую ситуацию: система не «застревает» (как в обычной взаимной блокировке), а занимается бесполезной работой, её состояние постоянно меняется — но, тем не менее, она «зациклилась», не производит никакой полезной работы.
Жизненный пример такой ситуации: двое встречаются лицом к лицу. Каждый из них пытается посторониться, но они не расходятся, а несколько секунд сдвигаются в одну и ту же сторону.

Состоя́ние го́нки (англ. race condition) — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода

GCD или Grand Central Dispatch — механизм распараллеливания задач, представленный в iOS 4 и Mac OS X 10.6. Суть механизма в том, что реализация многопоточности скрывается от программиста. Всю «заботу» о создании потоков берет на себя GCD. Утверждается, что задачи GCD легковесны и требуют меньше процессорного времени, чем создание потоков. Получается, что все что требуется от программиста — определить какие задачи выполнять и поставить в нужную очередь, а GCD уже разберется со всем остальным.

Многопоточная модель.
Наше приложение создает некоторое количество потоков (пул), передавая каждому из них задачу и данные для обработки. Задачи выполняются параллельно. Если потоки не имеют общих данных, то у нас не будет накладных расходов на синхронизацию, что делает работу достаточно быстрой. После завершения работы поток не убивается, а лежит в пуле, ожидая следующей задачи.

Асинхронная модель
Менее распространенная модель, нежели многопоточная, но имеющая не меньшие возможности. Асинхронная модель построена на очереди событий (event-loop). При возникновении некоторого события (пришел запрос, выполнилось считывание файла, пришел ответ от БД) оно помещается в конец очереди. Поток, который обрабатывает эту очередь, берет событие с начала очереди, и выполняет связанный с этим событием код. Пока очередь не пуста процессор будет занят работой.

Асинхронность - способность запустить операцию и не блокировать выполнение программы, а потом при наступлении какого-то события выполнить задачу.


Способы создания потоков:
pthread
NSObject performSelectorInBackground:
NSThread
GCD
NSOperation


## REST
REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем, таких как World Wide Web, который, как правило, используется для построения веб-служб
REST - философия разработки распределённых систем.

Шесть принципов(ограничений):
Единый интерфейс  
Определяет интерфейс между клиентами и серверами. Это упрощает и отделяет архитектуру, которая позволяет каждой части развиваться самостоятельно. Четыре принципа единого интерфейса:
Основан на ресурсах Отдельные ресурсы определяются в запросе, для чего используется URI, как идентификаторы ресурсов. Сами ресурсы концептуально отделены от представлений, которые возвращаются клиенту. Например, сервер не отправляет свою базу данных, а, скорее, некоторые HTML, XML или JSON, которые представляет некоторые записи в базе данных, например, на финском языке и в UTF-8, в зависимости от деталей запроса и реализации сервера. Манипуляции над ресурсами через представления Когда пользователь имеет представление о ресурсе, в том числе о связанных метаданных, он имеет достаточно информации для изменения или удаления ресурса на сервере, если у него есть на это разрешение Само-документируемые сообщения Каждое сообщение содержит достаточно информации для описания того, как его выполнить. Например, вызываемый парсер может описываться с помощью Internet media type (так же известным как MIME) Ответы также явно указывают на их способность кешировать.  Hypermedia as the Engine of Application State (HATEOAS) Клиенты предоставляют статус через содержимое body, параметры строки запроса, заголовки запросов и запрашиваемый URI (имя ресурса). Это называется гипермедиа (или гиперссылки с гипертекстом)  Наряду с приведенным выше описанием, HATEOS также означает, что, в случае необходимости ссылки содержатся в теле ответа (или заголовках) для поддержки URI извлечения самого объекта или запрошенных объектов. Позднее, мы затронем эту тему глубже. Единый интерфейс так же означает, что любой REST сервис должен обеспечивать его фундаментальный дизайн. 

2. Отсутствие состояний. 
Так как REST это акроним для REpresentational State Transfer, отсутствие состояний является важной 
чертой. Таким образом, это значит, что необходимое состояние для обработки запроса содержится в 
самом запросе, либо в рамках URI, параметрах строки запроса, тела или заголовках. URI уникально 
идентифицирует ресурс и тело содержит состояние (или изменение состояния) этого ресурса. Затем, 
после того, как сервер завершит обработку, состояние или его часть(и) отдается обратно клиенту 
через заголовки, статус и тело ответа. Большинство из нас, кто был в этой отрасли, привыкли к программированию в контейнере, 
который дает нам понятие "Сессия, которая поддерживает состояние нескольких HTTP запросов. В 
REST, клиент должен включать всю информация для сервера для выполнения запроса, перепосылая 
состояние по необходимости, если это состояние должно охватывать несколько запросов. Отсутствие 
состояний обеспечивает большую масштабируемость, так как сервер не должен поддерживать или 
общаться через состояние сеанса. Кроме того, балансировщику нагрузки не придется беспокоиться о 
связанности сессии и системы. Так в чем различие между состоянием и ресурсом? Состояние или состояние приложения, это 
то, что сервер заботится выполнить запрос для получения данных необходимых для текущей сессии 
или запроса. Ресурсное состояние, или ресурс, это данные, которые определяют представление 
ресурса, например, данные хранящиеся в базе данных. Рассмотрим состояние приложения как 
данные, которые могут варьироваться в зависимости от клиента и запроса. С другой стороны, 
состояние ресурсов постоянно по каждому клиенту, который запрашивает его. 
Каждый встречал проблему с кнопкой "Назад" в своем веб приложении, когда оно ведет себя по 
разному в одной точке, потому что ожидались действия в определенном порядке? Такое происходит, 
когда нарушен принцип отсутствия состояний. Есть случаи, когда не соблюдается принцип 
отсутствия состояний, например, three-legged OAuth, ограничение скорости вызова API и т.д. Однако, 
приложите максимум усилий, чтобы состояние приложения не занимало несколько запросов к 
вашему сервису.
3. Кеширование ответа:
Как и в World Wide Web, клиент может кэшировать ответы. Таким образом, ответы явно или неявно 
определяют себя как кешируемые или нет, для предотвращения поaniumвторного использования клиентами 
устаревших или некорректных данных в ответ на дальнейшие запросы. Хорошо спроектированное 
кэширование частично или полностью устраняет некоторые клиент-серверные взаимодействия, 
способствуя дальнейшей масштабируемости и производительности. 

4. Клиент-сервер: 
Единый интерфейс отделяет клиентов от серверов. Разделение интерфейсов 
означает, что, например, клиенты не связаны с хранением данных, которое остается внутри каждого 
сервера, так что мобильность кода клиента улучшается. Серверы не связаны с интерфейсом 
пользователя или состоянием, так что серверы могут быть проще и масштабируемы. Серверы и 
клиенты могут быть заменяемы и разрабатываться независимо, пока интерфейс не изменяется. 
5. Многоуровневая система:     
Обычно клиенты не могу сказать - они подключены напрямую к серверу или общаются через 
посредника. Промежуточный сервер может улучшить масштабируемость системы, обеспечивая 
балансировку нагрузки и предоставляя общий кэш. Слои также могут отвечать за политику 
безопасности. 
6. Код по требованию :
Серверы могут временно расширять или кастомизировать функционал клиента, передавая ему логику,
которую он может исполнять. Например, это могут быть скомпилированные Java-апплеты или
клиентские скрипты на Javascript
Соблюдая эти ограничения, и, таким образом, придерживаясь RESTful архитектуры, мы позволяем распределенной системе любого типа иметь такие свойства как: производительность, расширяемость, простота, обновляемость, понятность, портативность и надежность.
Замечание Единственным необязательным ограничением для RESTful архитектуры - это "код по требованию". Если сервис не проходит по любым другим условиям, то его совершенно точно нельзя назвать RESTful.

Клиент-сервер (англ. Client-server) — вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами. Физически клиент и сервер — это программное обеспечение. Обычно, они взаимодействуют через компьютерную сеть посредством сетевых протоколов и находятся на разных вычислительных машинах, но могут выполняться также и на одной машине. Программы — сервера, ожидают от клиентских программ запросы и предоставляют им свои ресурсы в виде данных (например, загрузка файлов посредством HTTP, FTP, BitTorrent, потоковое мультимедиа или работа с базами данных) или сервисных функций (например, работа с электронной почтой, общение посредством систем мгновенного обмена сообщениями, просмотр web-страниц во всемирной паутине).

Интерфе́йс (англ. interface — поверхность раздела; граница раздела; поверхность контакта; стык, область контакта, взаимодействия; средство осуществления взаимного воздействия, взаимосвязи) — совокупность возможностей, способов и методов одновременного взаимодействия двух систем (любых, а не обязательно являющихся вычислительными или информационными), устройств или программ для обмена информацией между ними, определённая их характеристиками, характеристиками соединения, сигналов обмена и т. п. В случае, если одна из взаимодействующих систем — человек, чаще говорят лишь о второй системе, то есть об интерфейсе той системы, с которой человек взаимодействует в режиме одновременности

## ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ

Структурные:
MVC — архитектурный паттерн проектирования, указывающий, что модель приложения, пользовательский интерфейс и взаимодействие с пользователем должны быть разделены на три отдельных компонента таким образом, чтобы модификация одного из компонентов оказывала минимальное воздействие на остальные. Данная схема проектирования часто используется для построения архитектурного каркаса, когда переходят от теории к реализации в конкретной предметной области

В оригинальной концепции была описана сама идея и роль каждого из элементов: модели, представления и контроллера. Но связи между ними были описаны без конкретизации. Кроме того, различали две основные модификации:
1    Пассивная модель — модель не имеет никаких способов воздействовать на представление или контроллер, и пользуется ими в качестве источника данных для отображения. Все изменения модели отслеживаются контроллером и он же отвечает за перерисовку представления, если это необходимо. Такая модель чаще используется в структурном программировании, так как в этом случае модель представляет просто структуру данных, без методов их обрабатывающих.
2    Активная модель — модель оповещает представление о том, что в ней произошли изменения, а представления, которые заинтересованы в оповещении, подписываются на эти сообщения. Это позволяет сохранить независимость модели как от контроллера, так и от представления.
Классической реализацией концепции MVC принято считать версию именно с активной моделью.

Концепция MVC позволяет разделить данные, представление и обработку действий пользователя на три отдельных компонента:
•    Модель (англ. Model). Модель предоставляет знания: данные и методы работы с этими данными, реагирует на запросы, изменяя своё состояние. Не содержит информации, как эти знания можно визуализировать.
•    Представление, вид (англ. View). Отвечает за отображение информации (визуализацию). Часто в качестве представления выступает форма (окно) с графическими элементами.
•    Контроллер (англ. Controller). Обеспечивает связь между пользователем и системой: контролирует ввод данных пользователем и использует модель и представление для реализации необходимой реакции.
Важно отметить, что как представление, так и контроллер зависят от модели. Однако модель не зависит ни от представления, ни от контроллера. Тем самым достигается назначение такого разделения: оно позволяет строить модель независимо от визуального представления, а также создавать несколько различных представлений для одной модели.

Model-View-Presenter (MVP) — шаблон проектирования, производный от MVC, который используется в основном для построения пользовательского интерфейса.
В MVP Presenter берет на себя функциональность посредника (играя роль, аналогичную контроллеру в MVC). Кроме того, Presenter отвечает за управление событиями пользовательского интерфейса (например, mouseDown, keyDown и т.д.), которое обычно было заботой представления. В итоге, модель становится строго моделью представления.

MVVM

Шаблон MVVM делится на три части:
•    Модель (англ. Model), так же, как в классической MVC, Модель представляет собой фундаментальные данные, необходимые для работы приложения.
•    Представление (англ. View) — это графический интерфейс, то есть окно, кнопки и т. п. Представление является подписчиком на событие изменения значений свойств или команд, предоставляемых Моделью представления. В случае, если в Модели представления изменилось какое-либо свойство, то она оповещает всех подписчиков об этом, и Представление, в свою очередь, запрашивает обновленное значение свойства из Модели представления. В случае, если пользователь воздействует на какой-либо элемент интерфейса, Представление вызывает соответствующую команду, предоставленную Моделью представления.
•    Модель представления (англ. ViewModel) является, с одной стороны, абстракцией Представления, а с другой, предоставляет обёртку данных из Модели, которые подлежат связыванию. То есть, она содержит Модель, которая преобразована к Представлению, а также содержит в себе команды, которыми может пользоваться Представление, чтобы влиять на Модель.
VIPER:


View: displays what it is told to by the Presenter and relays user input back to the Presenter.
Interactor: contains the business logic as specified by a use case.        
Presenter: contains view logic for preparing content for display (as received from the Interactor) and for reacting to user inputs (by requesting new data from the Interactor).        
Entity: contains basic model objects used by the Interactor        
Routing: contains navigation logic for describing which screens are shown in which order.

Реактивное программирование — парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что выполняемая модель должна автоматически распространять изменения сквозь поток данных.

Главные в iOs:

Делегирование - Объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.

Наблюдатель - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.

Декоратор - Класс, расширяющий функциональность другого класса без использования наследования.

Адаптер - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.

Цепочка ответственности - Предназначен для организации в системе уровней ответственности.

Одиночка- Предназначен для организации в системе уровней ответственности.

Target/Action - паттерн, при котором программа разделена на объекты, динамически устанавливающие связи между собой, сообщая друг другу на какой объект ссылаться и/или отправить сообщение этому объекту при возникновении определённого события.

Абстрактная фабрика - Класс, который представляет собой интерфейс для создания компонентов системы.

Строитель(Builder) - Класс, который представляет собой интерфейс для создания сложного объекта.




## Протоколы передачи данных


Протокол передачи данных  — набор соглашений интерфейса логического уровня, которые определяют обмен данными между различными программами.

Сетево́й протоко́л — набор правил и действий (очерёдности действий), позволяющий осуществлять соединение и обмен данными между двумя и более включёнными в сеть устройствами.

Список сетевых протоколов:
Канальный уровень:

Ethernet - ([ˈiːθərˌnɛt] от англ. ether [ˈiːθər] — «эфир» и англ. network — «сеть, цепь») — семейство технологий пакетной передачи данных для компьютерных сетей.
хDSL (англ. digital subscriber line, цифровая абонентская линия) — семейство технологий, позволяющих значительно повысить пропускную способность абонентской линии телефонной сети общего пользования путём использования эффективных линейных кодов и адаптивных методов коррекции искажений линии на основе современных достижений микроэлектроники и методов цифровой обработки сигнала.

Сетевой уровень:

Internet Protocol (IP, досл. «межсетевой протокол») — маршрутизируемый протокол сетевого уровня стека TCP/IP. Именно IP стал тем протоколом, который объединил отдельные компьютерные сети во всемирную сеть Интернет. Неотъемлемой частью протокола является адресация сети (см. IP-адрес).

Транспортный уровень:
UDP (англ. User Datagram Protocol — протокол пользовательских датаграмм) — один из ключевых элементов TCP/IP, набора сетевых протоколов для Интернета. С UDP компьютерные приложения могут посылать сообщения (в данном случае называемые датаграммами) другим хостам по IP-сети без необходимости предварительного сообщения для установки специальных каналов передачи или путей данных. Протокол был разработан Дэвидом П. Ридом в 1980 году и официально определён в RFC 768.

TCP (англ. Transmission Control Protocol, протокол управления передачей) — один из основных протоколов передачи данных Интернета, предназначенный для управления передачей данных в сетях и подсетях TCP/IP. Механизм TCP предоставляет поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери данных и устраняет дублирование при получении двух копий одного пакета, гарантируя тем самым, в отличие от UDP, целостность передаваемых данных и уведомление отправителя о результатах передачи.
В отличие от традиционной альтернативы — UDP, который может сразу же начать передачу пакетов, TCP устанавливает соединения, которые должны быть созданы перед передачей данных. TCP соединение можно разделить на 3 стадии:
Установка соединения
Передача данных
Завершение соединения

Сравнение TCP и UDP
TCP — ориентированный на соединение протокол, что означает необходимость «рукопожатия» для установки соединения между двумя хостами. Как только соединение установлено, пользователи могут отправлять данные в обоих направлениях.
•    Надёжность — TCP управляет подтверждением, повторной передачей и тайм-аутом сообщений. Производятся многочисленные попытки доставить сообщение. Если оно потеряется на пути, сервер вновь запросит потерянную часть. В TCP нет ни пропавших данных, ни (в случае многочисленных тайм-аутов) разорванных соединений.
•    Упорядоченность — если два сообщения последовательно отправлены, первое сообщение достигнет приложения-получателя первым. Если участки данных прибывают в неверном порядке, TCP отправляет неупорядоченные данные в буфер до тех пор, пока все данные не могут быть упорядочены и переданы приложению.
•    Тяжеловесность — TCP необходимо три пакета для установки сокет-соединения перед тем, как отправить данные. TCP следит за надёжностью и перегрузками.
•    Потоковость — данные читаются как поток байтов, не передается никаких особых обозначений для границ сообщения или сегментов.
UDP — более простой, основанный на сообщениях протокол без установления соединения. Протоколы такого типа не устанавливают выделенного соединения между двумя хостами. Связь достигается путем передачи информации в одном направлении от источника к получателю без проверки готовности или состояния получателя. В приложениях для голосовой связи через интернет-протокол (Voice over IP, TCP/IP) UDP имеет преимущество над TCP, в котором любое «рукопожатие» помешало бы хорошей голосовой связи. В VoIP считается, что конечные пользователи в реальном времени предоставят любое необходимое подтверждение о получении сообщения.
•    Ненадёжный — когда сообщение посылается, неизвестно, достигнет ли оно своего назначения — оно может потеряться по пути. Нет таких понятий, как подтверждение, повторная передача, тайм-аут.
•    Неупорядоченность — если два сообщения отправлены одному получателю, то порядок их достижения цели не может быть предугадан.
•    Легковесность — никакого упорядочивания сообщений, никакого отслеживания соединений и т. д. Это небольшой транспортный уровень, разработанный на IP.
•    Датаграммы — пакеты посылаются по отдельности и проверяются на целостность только если они прибыли. Пакеты имеют определенные границы, которые соблюдаются после получения, то есть операция чтения на сокете-получателе выдаст сообщение таким, каким оно было изначально послано.
•    Нет контроля перегрузок — UDP сам по себе не избегает перегрузок. Для приложений с большой пропускной способностью возможно вызвать коллапс перегрузок, если только они не реализуют меры контроля на прикладном уровне.

Прикладной уровень:
HTTP, SMTP и так далее
HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных (изначально — в виде гипертекстовых документов в формате HTML, в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология «клиент-сервер», то есть предполагается существование потребителей (клиентов), которые инициируют соединение и посылают запрос, и поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.
## БАЗЫ ДАННЫХ

Ба́за да́нных — представленная в объективной форме совокупность самостоятельных материалов (статей, расчётов, нормативных актов, судебных решений и иных подобных материалов), систематизированных таким образом, чтобы эти материалы могли быть найдены и обработаны с помощью электронной вычислительной машины (ЭВМ).
База данных — совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных
Нормальная форма — свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных. Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение.
Процесс преобразования отношений базы данных к виду, отвечающему нормальным формам, называется нормализацией. Нормализация предназначена для приведения структуры БД к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных.[1] Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации. Как отмечает К. Дейт,[2] общее назначение процесса нормализации заключается в следующем:
•    исключение некоторых типов избыточности;
•    устранение некоторых аномалий обновления;
•    разработка проекта базы данных, который является достаточно «качественным» представлением реального мира, интуитивно понятен и может служить хорошей основой для последующего расширения;
•    упрощение процедуры применения необходимых ограничений целостности.
Устранение избыточности производится, как правило, за счёт декомпозиции отношений таким образом, чтобы в каждом отношении хранились только первичные факты (то есть факты, не выводимые из других хранимых фактов).

Отношение - Пусть дана совокупность типов данных T1, T2, ..., Tn, называемых также доменами, не обязательно различных. Тогда n-арным отношением R, или отношением R степени n называют подмножество декартовa произведения множеств T1, T2, ..., Tn
В таблице не может быть двух одинаковых строк. В математике таблицы, обладающие таким свойством, называют отношениями - по-английски relation, отсюда и название - реляционные.

Что такое ключ? Набор столбцов. Он может состоять из одного столбца, или охватывать все столбцы таблицы. Для чего нам нужны ключи? Для идентификации строк таблицы. В чистой реляционной теории баз данных это единственный способ сослаться на строку. Ключи бывают разные - потенциальные, первичные, альтенативные, внешние, индексные, хеш-ключи, ключи сортировки, вторичные ключи, ключи шифрование и расшифровки и т.д. Но мы договаривались, что будем рассматривать только то, что нам понадобится в работе, вот и рассмотрим. Желающим углибить свои знания могу посоветовать прочитать уже упоминавшуюся выше книгу Дейта.

В реляционных базах данных кортеж — это элемент отношения. Для N-арного отношения кортеж представляет собой упорядоченный набор из N значений, по одному значению для каждого атрибута отношения.

Кортеж 
В реляционных базах данных кортеж — это элемент отношения. Для N-арного отношения кортеж представляет собой упорядоченный набор из N значений, по одному значению для каждого атрибута отношения.

В создании и развитии теории нормализации принимали участие многие учёные. Однако первые три нормальные формы и концепцию функциональной зависимости предложил Э. Кодд.
Первая нормальная форма (1NF)
Основная статья: Первая нормальная форма
Переменная отношения находится в первой нормальной форме (1НФ) тогда и только тогда, когда в любом допустимом значении отношения каждый его кортеж содержит только одно значение для каждого из атрибутов.
В реляционной модели отношение всегда находится в первой нормальной форме по определению понятия отношение. Что же касается различных таблиц, то они могут не быть правильными представлениями отношений и, соответственно, могут не находиться в 1НФ.
Вторая нормальная форма (2NF)
Основная статья: Вторая нормальная форма
Переменная отношения находится во второй нормальной форме тогда и только тогда, когда она находится в первой нормальной форме и каждый неключевой атрибут неприводимо (функционально полно) зависит от ее потенциального ключа.

Пример приведения отношения ко второй нормальной форме
Пусть в следующем отношении первичный ключ образует пара атрибутов {Сотрудник, Должность}:
Сотрудник
Должность
Зарплата
Наличие компьютера
Гришин
Кладовщик
20000
Нет
Васильев
Программист
40000
Есть
Иванов
Кладовщик
25000
Нет
Зарплату сотруднику каждый начальник устанавливает сам (хотя её границы зависят от должности). Наличие же компьютера у сотрудника зависит только от должности, то есть зависимость от первичного ключа неполная.
В результате приведения к 2NF исходное отношение следует декомпозировать на два отношения:
Сотрудник
Должность
Зарплата
Гришин
Кладовщик
20000
Васильев
Программист
40000
Иванов
Кладовщик
25000
Должность
Наличие компьютера
Кладовщик
Нет
Программист
Есть

Третья нормальная форма (3NF)
Основная статья: Третья нормальная форма
Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.

Рассмотрим в качестве примера отношение, которое находится во 2NF, но не соответствует 3NF:
R1
Сотрудник
Отдел
Телефон
Гришин
Бухгалтерия
11-22-33
Васильев
Бухгалтерия
11-22-33
Петров
Снабжение
44-55-66
В отношении атрибут «Сотрудник» является первичным ключом. Личных телефонов у сотрудников нет, и телефон сотрудника зависит исключительно от отдела.
Таким образом, в отношении существуют следующие функциональные зависимости: Сотрудник → Отдел, Отдел → Телефон, Сотрудник → Телефон.
Зависимость Сотрудник → Телефон является транзитивной, следовательно, отношение не находится в 3NF.
В результате разделения отношения R1 получаются два отношения, находящиеся в 3NF:
R2
Отдел
Телефон
Бухгалтерия
11-22-33
Снабжение
44-55-66
R3
Сотрудник
Отдел
Гришин
Бухгалтерия
Васильев
Бухгалтерия
Петров
Снабжение

Исходное отношение R1 при необходимости легко получается в результате операции соединения отношений R2 и R3.

Нормальная форма Бойса — Кодда (BCNF)
Основная статья: Нормальная форма Бойса — Кодда
Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая ее нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
Четвёртая нормальная форма (4NF)
Основная статья: Четвёртая нормальная форма
Переменная отношения находится в четвёртой нормальной форме, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей.
Пятая нормальная форма (5NF)
Основная статья: Пятая нормальная форма
Переменная отношения находится в пятой нормальной форме (иначе — в проекционно-соединительной нормальной форме) тогда и только тогда, когда каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.
Доменно-ключевая нормальная форма (DKNF)
Основная статья: Доменно-ключевая нормальная форма
Шестая нормальная форма (6NF)
Основная статья: Шестая нормальная форма
Введена К. Дейтом в его книге, как обобщение пятой нормальной формы для темпоральной базы данных.


ORM (англ. object-relational mapping, рус. объектно-реляционное отображение) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных»

Транза́кция (англ. transaction) — группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, либо не выполнена вообще и тогда она не должна произвести никакого эффекта. Транзакции обрабатываются транзакционными системами, в процессе работы которых создаётся история транзакций.

Свойства транзакций:
Одним из наиболее распространённых наборов требований к транзакциям и транзакционным системам является набор ACID (Atomicity, Consistency, Isolation, Durability). Требования ACID были в основном сформулированы в конце 70-х годов Джимом Греем[1]. Вместе с тем, существуют специализированные системы с ослабленными транзакционными свойствами

1. Atomicity  - Атомарность - гарантирует, что никакая транзакция не будет зафиксирована в системе частично.
Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся в исходное состояние.
2. Consistency — Согласованность
Одно из самых сложных и неоднозначных свойств из четвёрки ACID. В соответствии с этим требованием, система находится в согласованном состоянии до начала транзакции и должна остаться в согласованном состоянии после завершения транзакции. Не нужно путать требование согласованности с требованиями целостности (integrity). Последние правила являются более узкими и, во многом, специфичны для реляционных СУБД: есть требования целостности типов (domain integrity), целостности ссылок (referential integrity), целостности сущностей (entity integrity), которые не могут быть нарушены физически в силу особенностей реализации системы.
Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисление, то система останется в некорректном состоянии и свойство согласованности будет нарушено.
Наконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего, двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции, никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.
3. Isolation — Изолированность
Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Это свойство не соблюдается на уровне изолированности Repeatable Read и ниже.
Уровни изоляции транзакций:
В идеале транзакции разных пользователей должны выполняться так, чтобы создавалась иллюзия, что пользователь текущей транзакции — единственный. Однако в реальности, по соображениям производительности и для выполнения некоторых специальных задач, СУБД предоставляют различные уровни изоляции транзакций.
Уровни описаны в порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными.
•    0 — Чтение неподтверждённых данных (грязное чтение) (Read Uncommitted, Dirty Read) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения (lost changes), возможны неповторяемое чтение и фантомы.
•    1 — Чтение подтверждённых данных (Read Committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы.
•    2 — Повторяемое чтение (Repeatable Read, Snapshot) — чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.
•    3 — Сериализуемый — (Serializable) — сериализуемые транзакции. Результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают.
Чем выше уровень изоляции, тем больше требуется ресурсов, чтобы его обеспечить. Соответственно, повышение изолированности может приводить к снижению скорости выполнения параллельных транзакций, что является «платой» за повышение надёжности.
В СУБД уровень изоляции транзакций можно выбрать как для всех транзакций сразу, так и для одной конкретной транзакции. По умолчанию в большинстве баз данных используется уровень 1 (Read Committed). Уровень 0 используется в основном для отслеживания изменений длительных транзакций или для чтения редко изменяемых данных. Уровни 2 и 3 используются при повышенных требованиях к изолированности транзакций.
4. Durability — Надежность
Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
## 2. Принципы функционального программирования

Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).

Краткость и простота
Программы на функциональных языках обычно короче и проще, чем те же самые программы на императивных языках.
Строгая типизация
Из современных языков программирования многие суть строго типизированные. Строгая типизация позволяет компилятору оптимизировать программы, использовать конкретные типы и контейнеры конкретных типов вместо шаблонных, вариантных типов, более громоздких в реализации. Кроме того, строгая типизация позволяет оградиться от части ошибок, связанных с неожидаемым «видом» входных (и выходных) данных, причем это происходит на стадии компиляции, не отнимая на такие проверки время при работе программы. Система типов также способствует «документированию» программы: любая подпрограмма является функцией в математическом смысле слова, отображая одно множество (входное) на другое (выходное), и типы определяют эти множества. Читабельность программ повышается, если используются псевдонимы типов или сложные типы, собранные на основе простых, вместо базовых элементарных целых, строк и т. п.

Модульность
Механизм модульности позволяет разделять программы на несколько сравнительно независимых частей (модулей) с чётко определёнными связями между ними. Так облегчается процесс проектирования и последующей поддержки больши́х программных систем. Поддержка модульности не есть свойство именно функциональных языков программирования, но поддерживается большинством таких языков. Существуют очень развитые модульные императивные языки.

Функции суть значения
В функциональных языках, равно как и вообще в языках программирования и математике, функции могут быть переданы другим функциям в качестве аргумента или возвращены в качестве результата. Функции, принимающие функциональные аргументы, называются функциями высших порядков или функционалами. Самый, пожалуй, известный функционал — функция map. Она применяет некоторую функцию ко всем элементам списка, формируя из результатов заданной функции другой список. Например, определив функцию возведения целого числа в квадрат как:
square n = n * n
Можно воспользоваться функцией map для возведения в квадрат всех элементов некоторого списка:
squareList = map square [1, 2, 3, 4]
Результатом будет список [1, 4, 9, 16].

Чистота
(отсутствие побочных эффектов)
В императивных языках функция в процессе своего выполнения может читать и изменять значения глобальных переменных и осуществлять операции ввода-вывода. Поэтому, если вызвать одну и ту же функцию дважды с одним и тем же аргументом, может случиться так, что в качестве результата вычислятся два различных значения. Изменение функцией состояния программы иначе, чем через возвращение значения, называется побочным эффектом.
Описывать функции без побочных эффектов позволяет практически любой язык. Однако некоторые языки поощряют или даже требуют от функции побочных эффектов. Например, во многих объектно-ориентированных языках в функцию-член класса передаётся скрытый параметр (чаще он называется this или self), который эта функция неявно изменяет.
В чистом функциональном программировании оператор присваивания отсутствует, объекты нельзя изменять и уничтожать, можно только создавать новые путём разбора и сбора существующих. О ненужных объектах позаботится встроенный в язык сборщик мусора. Благодаря этому в чистых функциональных языках все функции свободны от побочных эффектов. Однако это не мешает этим языкам имитировать некоторые полезные императивные свойства, такие как исключения и изменяемые массивы.

Отложенные вычисления
В традиционных языках программирования (например, Си++) вызов функции приводит к вычислению всех аргументов. Этот метод вызова функции называется вызов по значению. Если какой-либо аргумент не использовался в функции, то результат вычислений пропадает, следовательно, вычисления были произведены впустую. В каком-то смысле противоположностью вызова по значению является вызов по необходимости. В этом случае аргумент вычисляется, только если он нужен для вычисления результата. Примером такого поведения можно взять оператор конъюнкции всё из того же Си++ (&&), который не вычисляет значение второго аргумента, если первый аргумент имеет ложное значение.

Функции высшего порядка
Функция, в которую передали другую функцию

Продолжения int j = add(5, 10, square);

Сопоставление с образцом (англ. Pattern matching) — метод анализа и обработки структур данных, основанный на выполнении определенных инструкций в зависимости от совпадения исследуемого значения с тем или иным образцом, в качестве которого может использоваться константа, предикат, тип данных или иная поддерживаемая языком конструкция.

Замыкание (англ. closure) в программировании — функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами. Говоря другим языком, замыкание — функция, которая ссылается на свободные переменные в своём контексте.

http://habrahabr.ru/post/142351/

Карирование - преобразование функции от многих аргументов в функцию, берущую свои аргументы по одному
int pow(int i, int j);
int square(int i)
{
return pow(i, 2);
}

Мона́да в функциональном программировании — это абстракция линейной цепочки связанных вычислений. Её основное назначение — инкапсуляция функций с побочным эффектом от чистых функций, а точнее их выполнений от вычислений

Функциональный объект (англ. function object), также функтор, функционал и функционоид — распространённая в программировании конструкция, позволяющая использовать объект как функцию. Часто используется как callback, делегат, либо как замена лямбда-выражениям в нефункциональных языках программирования.

## Core Data

Что такое Core Data: 
Core Data скорее является оболочкой/фрэймворком для работы с данными, которая позволяет работать с сущностями и их связями (отношениями к другим объектами), атрибутами, в том виде, который напоминает работы с объектным графом в обычном объектно-ориентированном программировании
2. NSManagedObjectContext - класс для управления NSManagedObject
3. NSManagedObject - общий класс, который описывает всё поведение, нужное для модельного объекта Core Data. Можно сказать, что работает он как NSDictionary - объект, который эффективно предоставляет хранение данных, ассоциированных с NSEntityDescription. NSManagedObject ассоциирован с  NSEntityDescription 
4. NSManagedObject Faulting - Иногда NSManagedObject может быть «Fault» - объект, свойства которого еще не успели загрузиться из хранилища.
5. NSManagedObjectID - компактный универсальный идентификатор объекта в NSPersistentStore. Есть bool property temporaryID - Новым объектам, добавленные в NSManagedObjectContext, присваивается временный NSManagedObjectID. А после сохранения контекста - постоянные.
6. NSPersistentStoreCoordinator - класс, связывающий хранилище(NSPersistentStore) с моделью и служит посредником между хранилищем/хранилищами(NSPersistentStore) и контекстами(NSManagedObjectContext)
7. NSManagedObjectModel - объект, описывающий схему данных - список entity, используемых в приложении.
8. NSFetchedResultsController - класс, помогающий эффективно предоставить выбранные данные из NSFetchRequest в UITableView или UICollectionView
9. Синхронизация потоков: нужно передать из одного контекста объекты в другой. На современный лад - создает конкаррент контекст, сохраняем, его используя performBlock и в ней же сохраняем главный контектс. - https://habrahabr.ru/post/238901/
10. Почему relationship являются двусторонними (bidirectional) - Core Data использует информацию о связях для того, чтобы убедиться в консистентности (постоянства) объектного графа в случае изменений. 
11. Fetched Property - слабая, однонаправленная relationship. это property, который добавляется к сабклассу NSManagedObject и вместо того, чтобы хранить значение, хранит NSFetchRequest.
Кейс для использования - 2 базы данных. БД с рецептам, которую мы хотим подгружать из файла и оставить readonly. И БД комментариев к рецептам. Fetched Property сначала делает выборку, потом ее кеширует. После кеша надо делать новый fetch request. 
http://www.cimgf.com/2014/01/01/fetched-properties-useful/

## Core Animation

CALayer - класс, управляющий битмапом изображения и
n

Most layers do not do any actual drawing in your app. Instead, a layer captures the content your app provides and caches it in a bitmap, which is sometimes referred to as the backing store. When you subsequently change a property of the layer, all you are doing is changing the state information associated with the layer object. When a change triggers an animation, Core Animation passes the layer’s bitmap and state information to the graphics hardware, which does the work of rendering the bitmap u

## Swift

1. Generics: Обобщённое программирование (англ. generic programming) — парадигма программирования, заключающаяся в таком описании данных и алгоритмов, которое можно применять к различным типам данных, не меняя само это описание
В языках программирования сопоставление с образцом (англ. Pattern matching) — метод анализа и обработки структур данных, основанный на выполнении определённых инструкций в зависимости от совпадения исследуемого значения с тем или иным образцом, в качестве которого может использоваться константа, предикат, тип данных или иная поддерживаемая языком конструкция.

Swift’s access control model is based on the concept of modules and source files.
A module is a single unit of code distribution—a framework or application that is built and shipped as a single unit and that can be imported by another module with Swift’s import keyword.3. Принципы SOLID


## SOLID это аббревиатура пяти основных принципов дизайна классов в объектно-ориентированном проектировании — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion.

Single responsibility - Принцип единственной обязанности - На каждый класс должна быть возложена одна-единственная обязанность. (Для каждого класса должна быть единственная причина для изменения)
Пример - нарисовать фигуры, а потом сложить все точки, а затем вывести сумму. Классы: Круг, Квадрат, Калькулятор (не только считает, но у него есть еще и функция output). Потом нам говорят вывести в json, xml, html и т.д. И вот тут понятно, что класс Калькулятор нарушает принцип единственной обязанности. Следует добавить класс РезалтАутпутер с методами вывода данных.

Open-closed - Принцип открытости/закрытости - Программные сущности должны быть открыты для расширения, но закрыты для изменения.
Пример - самый простой способ нарушения - использовать объекты без абстракций.
Пример - функция sum в классе калькулятор проверяет тип фигуры(if/else) и в зависимости от нее считает занимаемую область, потом суммирует. Если при изменении требований нам нужна еще фигура, то придётся изменять класс калькулятор - нарушение открытости/закрытости. Нам следует создать интерфейс Шейп с методом вычисления поверхности (area). Интерфейс имплементят все классы-фигуры, реализуя вычисление своей поверхности. Тогда можно заменить if/esle на вызов этого метода area и сложить их последовательно.

Liskov substitution - Принцип подстановки Барбары Лисков - Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
(Каждый сабкласс должен быть заменим на свой суперкласс).
Пример - проверка абстракции на тип.
Пример - Vehicle (с методами startEngine, accelerate, stopEngine) и subclass Car, Bus и класс Driver, который может спокойно его использовать. Потом нас просят добавить Bicycle. И тут все рушится
классика - Rectangle а от него наследует Square.

Interface segregation - Принцип разделения интерфейса - Много специализированных интерфейсов лучше, чем один универсальный.
Пример : UIAppDelegateProtocol


Dependency inversion - Принцип инверсии зависимостей - Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Пример - подключение к бд. Есть класс MySQLDBConnection и PasswordReminder. PasswordReminder в конструкторе принимает MySQLDBConnection объект. Это и есть нарушение принципа инверсии зависимости. Если мы вдруг поменяем бд для хранения пароля, то нам никак не воспользоваться этим кодом. Нужно сделать интерфейс DBConnection  и в PasswordReminder конструктор принимать интерфейс DBConnection.

Инверсия управления (англ. Inversion of Control, IoC) — важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления в компьютерных программах. Также архитектурное решение интеграции, упрощающее расширение возможностей системы, при котором контроль над потоком управления программы остаётся за каркасом.
Формулировка:
•    Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции.
•    Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Методы реализации
•    Фабричный метод (англ. Factory Method pattern)
•    Service locator - специальный объект для нахождения сервисов
•    Внедрение зависимости (англ. Dependency injection)
•    Через метод класса (англ. Setter injection)
•    Через конструктор (англ. Constructor injection)
•    Через интерфейс внедрения (англ. Interface injection)
•    IoC контейнер (англ. IoC-container)
## 4. Принципы KISS 

KISS (англ. keep it simple, stupid — буквально — «делай это проще, тупица» или более вежливый вариант англ. keep it short and simple — «делай короче и проще») — процесс и принцип проектирования,[1] при котором простота системы декларируется в качестве основной цели и/или ценности. Имеют хождение разные расшифровки этого акронима. Эрик Рэймонд в своей книге резюмирует философию UNIX как широко используемый принцип KISS.

## 5. Принцип «YAGNI» (англ. You Ain't Gonna Need It — «Вам это не понадобится») — процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — т. е. отказ добавления функциональности, в которой нет непосредственной надобности.

Согласно адептам принципа YAGNI, желание писать код, который не нужен прямо сейчас, но может понадобиться в будущем, приводит к следующим нежелательным последствиям:
•    Тратится время, которое было бы затрачено на добавление, тестирование и улучшение необходимой функциональности.
•    Новые функции должны быть отлажены, документированы и сопровождаться.
•    Новая функциональность ограничивает то, что может быть сделано в будущем, — ненужные новые функции могут впоследствии помешать добавить новые нужные.
•    Пока новые функции действительно не нужны, трудно полностью предугадать, что они должны делать, и протестировать их. Если новые функции тщательно не протестированы, они могут неправильно работать, когда впоследствии понадобятся.
•    Это приводит к тому, что программное обеспечение становится более сложным (подчас чрезмерно сложным).
•    Если вся функциональность не документирована, она может так и остаться неизвестной пользователям, но может создать для безопасности пользовательской системы различные риски.
•    Добавление новой функциональности может привести к желанию ещё более новой функциональности, приводя к эффекту «снежного кома».

6. Don’t repeat yourself, DRY (рус. не повторяйся) — это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования.


## Autolayout
Auto layout - система верстки, устанавливающая связи между представлениями, указывающая как представления взаимосвязаны с супервью и между собой. Auto layout основывается на Cassowary - инкрементальный инструментарий для вычисления constraints, использующий систему линейных уравнений и неравенств.
NSLayoutConstraint - правило, описывающее взаимосвязь между представлениями.
В кокоа верно заданный интерфейс называется satisfiable(Правильный, валидный) и sufficient (Достаточный)
button2.leading = multiplier × button1.trailing + constant

intrinsic content size - естественный размер контента вида. Есть не у всех. UIView - отсутствует. UIButton, UILabel… - есть. UITextView, UIImageView - может изменяться

content hugging priority - удаляет лишний padding вокруг контента или предотвращает его растягивание.

content compression resistance - контент представления не желает уменьшаться. Представление с высоким приоритетом compression resistance сопротивляется сжатию. В таком случае оно не даст контенту быть обрезаным.

Если добавить к представлению тени, бейджи и пр., то его естественный размер будет отличаться. В AutoLayout констрэйнты определяют размеры представления и положение использую геометрический элемент, называемый alignment rectangle.

alignment rectangle - тот, что использует автолэаут - без орнамента и украшений

frame rectangle - с орнаментом и украшениями

layout margin - расстояние UIView от superview по умолчанию.

NSLayoutAnchor - class для быстрого и удобного создания NSLayoutConstraint объектов.

Создание констрейнтов:

(id)constraintWithItem:(id)view1                          attribute:(NSLayoutAttribute)attr1                          relatedBy:(NSLayoutRelation)relation                             toItem:(id)view2                          attribute:(NSLayoutAttribute)attr2                         multiplier:(CGFloat)multiplier                           constant:(CGFloat)c

view1 - The view for the left side of the constraint.
attribute1 - The attribute of the view for the left side of the constraint.
relation - The relationship between the left side of the constraint and the right side of the constraint.
view2 - The view for the right side of the constraint.
attr2 - The attribute of the view for the right side of the constraint.
multiplier - The constant multiplied with the attribute on the right side of the constraint as part of getting the modified attribute.
c - The constant added to the multiplied attribute value on the right side of the constraint to yield the final modified attribute.
priority - priority level of the constraint. If a constraint's priority level is less than UILayoutPriorityRequired in iOS, then it is optional. Higher priority constraints are met before lower priority constraints.

## Тестирование:
Модульное тестирование, или юнит-тестирование (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.

Интеграцио́нное тести́рование (англ. Integration testing, иногда называется англ. Integration and Testing, аббревиатура англ. I&T) — одна из фаз тестирования программного обеспечения, при которой отдельные программные модули объединяются и тестируются в группе. Обычно интеграционное тестирование проводится после модульного тестирования и предшествует системному тестированию.
•    Компонентный интеграционный уровень (Component Integration testing - Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.
•    Системный интеграционный уровень (System Integration Testing) Проверяется взаимодействие между разными системами после проведения системного тестирования.

Приемочное тестирование
Формальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью:
•    определения удовлетворяет ли система приемочным критериям;
•    вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.
Приемочное тестирование выполняется на основании набора типичных тестовых случаев и сценариев, разработанных на основании требований к данному приложению. 
Решение о проведении приемочного тестирования принимается, когда:
•    продукт достиг необходимого уровня качества;
•    заказчик ознакомлен с Планом Приемочных Работ (Product Acceptance Plan) или иным документом, где описан набор действий, связанных с проведением приемочного тестирования, дата проведения, ответственные и т.д.
Фаза приемочного тестирования длится до тех пор, пока заказчик не выносит решение об отправлении приложения на доработку или выдаче приложения.

## Objective-c
Objective-C — компилируемый объектно-ориентированный язык программирования, используемый корпорацией Apple, построенный на основе языка Си и парадигм Smalltalk.
Динами́ческая типиза́ция — приём, широко используемый в языках программирования и языках спецификации, при котором переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Таким образом, в различных участках программы одна и та же переменная может принимать значения разных типов.

Class cluster:
Абстрактный класс, объединяющий набор конкретных приватных сабклассов (объектов),
предоставляющий упрощённый интерфейс для пользователя с помощью абстрактного класса.

Push notifications:

1    iOS запрашивает у сервера Apple Push Notification Service (APNS) токен девайса.
2    Приложение получает токен девайса. Можно считать, что токен – это адрес для отправки push-уведомлений.
3    Приложение отправляет токен девайса на ваш сервер.
4    Когда произойдёт какое-либо событие для вашего приложения, сервер отправит push-уведомление в APNS.
5    APNS отправит push-уведомление на девайс пользователя.

Designated initializer: у классов есть много инишиалайзеров. Тот, который вызывает [super init] - Designated initializer, а другие все вызывают его
Почему нужно вызывать self = [super init]?
Обратите внимание, что метод(ы) init является обычным методом, ничем не выделяющимся среди остальных
Поэтому при создании нового класса и метода init вызов переопределенного метода init (при помощи [super init]) должен быть произведен явно в самом начале метода.

frame и bounds - разница: 
frame - показывает координаты вида в системе координат родителя вида
bounds - показывает координаты вида в собственной системе координат
self.bounds is equal to CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)

Отличия nil, Nil, NSNull
Си определяет ничто как 0 (ноль) для большинства базовых (примитивных) типов и как NULL исключительно для указателей. 
nil - это указатель на нулевой объект.
Nil - нулевой указатель типа Class
NSNull — это своего рода обёртка над NULL и nil, позволяющая хранить их в объектах-коллекциях Objective-C

Reference counting:
http://www.tomdalling.com/blog/cocoa/an-in-depth-look-at-manual-memory-management-in-objective-c/
Что такое подсчет ссылок? 
Каждый объект использует подсчет ссылок для управления жизненным циклом. Подсчет ссылок позволяет одному объекту иметь несколько «владельцев» (owners) и убедиться в том, что объект будет существовать до тех пор, пока имеет хотя бы одного «владельца». Когда последний «владелец» исчезает, объект сам удаляется из памяти.
Подсчет ссылок - простая концепция и работает следующим образом:
Каждый объект имеет счетчик ссылок (reference count) - uint
Счетчик ссылок увеличивается на единицу при создании объекта и тот, кто создал объект, автоматически владеет им. (Ownership)
Если конкретный объект хочет владеть другим, он увеличивает счетчик ссылок на 1
Когда объект вам больше не нужен, при отправке сообщения release счетчик ссылок уменьшается на единицу.
Когда счетчик ссылок объекта становится равным нулю, он может быть безопасно удален из памяти.
NSAutoreleasePool - объект, который накапливает в себе объекты, которым было послано сообщение autorelease и через некоторое время удаляет их (drain).

Зачем нужны Root Classes:
Root class является единой точкой входа, в которой другие классы «общаются» с objc runtime
Category vs Extension
Категории - фишка objc, позволяющая добавлять свойства и методы в существующий класс
Extension - специальный случай категорий, который позволяет объявлять методы, которые реализуются в main @implementation блоке

Notifications vs Delegates
Notifications - уведомить несколько ресиверов
Delegate - отправить одному потребителю

NSSet vs NSArray
NSSet - поиск быстрее чем в array без дубликатов
NSArray - упорядоченные элементы, поиск медленнее

NSSet
•    Primarily access items by comparison
•    Unordered
•    Does not allow duplicates
NSArray
•    Can access items by index
•    Ordered
•    Allows duplicates

Formal vs Informal Protocols

A formal protocol declares a list of methods that client classes are expected to implement. Formal protocols have their own declaration, adoption, and type-checking syntax. You can designate methods whose implementation is required or optional with the @required and @optional keywords. Subclasses inherit formal protocols adopted by their ancestors. A formal protocol can also adopt other protocols.

An informal protocol is a category on NSObject, which implicitly makes almost all objects adopters of the protocol. (A category is a language feature that enables you to add methods to a class without subclassing it.) Implementation of the methods in an informal protocol is optional. Before invoking a method, the calling object checks to see whether the target object implements it. Until optional protocol methods were introduced in Objective-C 2.0, informal protocols were essential to the way Foundation and AppKit classes implemented delegation

Fast Enumeration
Several Cocoa classes, including the collection classes, adopt the NSFastEnumeration protocol. You use it to retrieve elements held by an instance using a syntax similar to that of a standard C for loop, as illustrated in the following example: for in loop.

NSZone
NSZone is Apple's way of optimizing object allocation and freeing. NSZone is not an object; it is an opaque C-struct storing information about how memory should be handled for a set of objects.

@dynamic
@synthesize will generate getter and setter methods for your property. @dynamic just tells the compiler that the getter and setter methods are implemented not by the class itself but somewhere else (like the superclass or will be provided at runtime).
Uses for @dynamic are e.g. with subclasses of NSManagedObject (CoreData) or when you want to create an outlet for a property defined by a superclass that was not defined as an outlet

Write-back
pass-by-writeback
NSError *error; // strong
BOOL ok = [myObject tryWithError:&error];

// translated to

NSError *__strong error;
NSError *__autoreleasing tmp = error;
BOOL ok = [myObject tryWithError:&tmp];
error = tmp;


Blocks
Obj-C блоки

Блоки — это объекты, создаются они на стеке (в последситвие они могут быть перенесены в кучу (heap))
Блоки могут существовать в виде 3-х имплементаций [7].

1    Когда мы не используем переменные из контекста (из стека) внутри блока — создается NSGlobalBlock, который реализован в виде синглтона.
2    Если мы используем контекстные переменные, то создается NSStackBlock, который уже не является синглтоном, но распологается на стеке.
3    Если мы используем функцию Block_copy, или хотим чтобы наш блок был сохранен внутри какого-то объекта размещенного в кучи, например как свойство объекта: @property (nonatomic, copy) MyBlockType myBlock; то создается объект класса NSMallocBlock, который захватывает и овладевает (овладевает == посылает сообщение retain) объектами переданными в контексте. Это очень важное свойство, потому как может приводить к утечкам памяти, если с ним обращаться невнимательно. Блоки могут создавать циклы владения (retain cycle). Еще важно отметить, что если мы будем использовать значение property в NSMallocBlock — ретейниться будет не само свойство, а объект которому свойство принадлежит.


https://felixha.wordpress.com/2014/10/20/blocks/
https://habrahabr.ru/company/viber/blog/232185/


SOLID, KVC, KVO, Agile, SOA, Scrum, Предметно-ориентированное проектирование (DDD) (англ. Domain-driven design) — это набор принципов и схем, помогающих разработчикам создавать изящные системы объектов. При правильном применении оно приводит к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит сложная бизнес-логика, устраняющая промежуток между реальными условиями области применения продукта и кодом

Основные определения
•    Область (англ. domain, домен) — предметная область, к которой применяется разрабатываемое программное обеспечение.
•    Модель (англ. model) — описывает отдельные аспекты домена и может быть использована для решения проблемы.
•    Язык описания — используется для единого стиля описания домена и модели.
Концепция
В идеале, при проектировании хочется иметь одну-единственную модель, которая полностью описывает всю предметную область, но в реальности, для упрощения процесса разработки продукта, домен представляют в виде сочетания нескольких взаимосвязанных моделей.
Схема архитектуры приложения представляет собой сочетание и описание одной или нескольких моделей предметной области и их взаимосвязей между собой.
Ограниченные связи[править | править вики-текст]
Использование нескольких моделей на различных уровнях проекта. Данный подход используется для уменьшения различных связей между моделями, что исключает сложность и запутанность кода. Иногда бывает неясно, в каком именно контексте должна использоваться модель.
Решение: Точно определить контекст, в котором используется модель. Определить границы использования данной модели и ее характеристики.
Целостность[править | править вики-текст]
Когда над проектом работает большое количество людей, то есть тенденция дробить модель на несколько, более мелких, фрагментов. Чем больше людей, тем более значительна данная проблема. В конечном итоге теряется целостность проекта.
Решение: Постоянное объединение кусков кода от различных разработчиков и проверка работоспособности посредством тестирования. Это позволяет держаться всем разработчикам в одной большой концепции.
Взаимосвязь[править | править вики-текст]
При работе над несколькими отдельными моделями в большой группе, различные члены команды могут не знать о сущностях других моделей, что усложняет процесс общей сборки конечного продукта.
Решение: На этапе проектирования точно обозначьте, что именно выполняет каждая модель и как она взаимосвязана с другими моделями. В конечном итоге у вас должна получиться карта взаимосвязей моделей.

Элементы DDD
При проектировании на основе проблемно-ориентированного подхода используются следующие понятия:
Контекст
В большинстве систем для предприятий используются крупномасштабные зоны ответственности. В DDD этот высший уровень организации называется ограниченным контекстом. Например, система биллинга крупной телекоммуникационной компании может иметь следующие ключевые элементы:
•    клиентская база
•    система безопасности и защиты
•    резервное копирование
•    взаимодействие с платежными системами
•    ведение отчетности
•    администрирование
•    система уведомлений
Все перечисленные элементы должны быть включены в единую, работающую без перебоев систему. При проектировании система уведомлений и система безопасности выделяются как совершенно разные вещи. Системы, в которых при реализации не удаётся разделить и изолировать ограниченные контексты, часто приобретают архитектурный стиль, который имеет красноречивое название «Большой ком грязи» в 1999 г. Брайан Фут (Brian Foot) и Йозеф Йодер (Joseph Yoder).
Сутью проблемно-ориентированного проектирования является конкретное определение контекстов и ограничение моделирования в их рамках.
Сущность
Проще всего сущности выражать в виде существительных: люди, места, товары и т. д. У сущностей есть и индивидуальность, и жизненный цикл. Во время проектирования думать о сущностях следует как о единицах поведения, нежели как о единицах данных. Чаще всего какие-то операции, которые вы пытаетесь добавить в модель, должна получить какая-то сущность, или при этом начинает создаваться или извлекаться новая сущность. В более слабом коде можно найти массу служебных или управляющих классов, проверяющих сущности снаружи.
Объект-значение
Объект-значение — это свойства, важные в той предметной области, которую вы моделируете. У них, в отличие от сущностей, нет обозначения; они просто описывают конкретные сущности, которые уже имеют обозначения. Полезность объектов-значений состоит в том, что они описывают свойства сущностей гораздо более изящным и объявляющим намерения способом. Стоит всегда помнить, что значение объекта никогда не изменяется на протяжении выполнения всего программного кода. После их создания, внесение поправок невозможно.
Сводный корень
Сводный корень — специальная сущность, к которой напрямую обращаются потребители. Использование при проектировании концепции сводных корней позволяет избегать чрезмерного соединения объектов между собой, составляющих модель, за счет применения правила: сводные корни — единственный вид сущностей, на который может ссылаться используемая программа. Это позволяет избежать путаницы и упростить структуру архитектуры кода, потому что теперь у вас есть специальное ограничение, не дающее создавать тесно связанные системы, где все сопряжено со всем.
Службы
Иногда в предметной области есть операции или процессы, у которых нет обозначения или жизненного цикла. Службы области дают инструмент для моделирования этих концепций. Они характеризуются отсутствием состояния и высокой связностью, часто предоставляя один открытый метод и иногда перегрузку для действий над наборами. Если в поведение включено несколько зависимостей, и нет возможности найти подходящего места в сущности для размещения этого поведения, в этом случае используют службу. Хотя сам по себе термин «служба» в мире разработки перегружен различными значениями, но в данной тематике, это обозначает небольшой класс, не представляющий конкретного человека, место или вещь в проектируемом приложении, но включающий в себя какие-то процессы. Использование служб позволяет ввести многослойную архитектуру, так же интегрировать несколько моделей, что вносит зависимость от инфраструктуры

